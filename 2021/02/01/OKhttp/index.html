<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="author" content="relax" />
  <meta name="description" content="" />
  
  
  <title>
    
      Okhttp原理分析 
      
      
      |
    
     relax&#39;s blog
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">relax's blog</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="https://github.com/relaxgao-lab">
          <a target="_blank" rel="noopener" href="https://github.com/relaxgao-lab">Github</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">Okhttp原理分析</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2023-05-06 08:05:30
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/android/" title="android">
                    #android
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/okhttp/" title="okhttp">
                    #okhttp
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h3 id="OkHttp介绍"><a href="#OkHttp介绍" class="headerlink" title="OkHttp介绍"></a>OkHttp介绍</h3><p>OKHttp是当下Android使用最频繁的网络请求框架，由Square公司开源。Google在Android4.4以后开始将源码中 的HttpURLConnection底层实现替换为OKHttp，同时现在流行的Retroﬁt框架底层同样是使用OKHttp的。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul>
<li>支持Http1、Http2、Quic以及WebSocket</li>
<li>连接池复用底层TCP(Socket)，减少请求延时</li>
<li>无缝的支持GZIP减少数据流量</li>
<li>缓存响应数据减少重复的网络请求</li>
<li>请求失败自动重试主机的其他ip，自动重定向 …….</li>
</ul>
<h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><img src="/2021/02/01/OKhttp/okhttp_%20flowchart.png" class="">


<figure class="highlight plaintext"><figcaption><span>okhttp3.*;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class OkHttpExample &#123;</span><br><span class="line"></span><br><span class="line">    private final OkHttpClient client = new OkHttpClient();</span><br><span class="line"></span><br><span class="line">    // 异步请求示例</span><br><span class="line">    public void runAsyncRequest(String url) &#123;</span><br><span class="line">        Request request = new Request.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        client.newCall(request).enqueue(new Callback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onFailure(Call call, IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class="line">                System.out.println(response.body().string());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 同步请求示例</span><br><span class="line">    public void runSyncRequest(String url) throws IOException &#123;</span><br><span class="line">        Request request = new Request.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        try (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">            System.out.println(response.body().string());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OkHttpExample example = new OkHttpExample();</span><br><span class="line">        String url = &quot;https://jsonplaceholder.typicode.com/posts/1&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            example.runSyncRequest(url);</span><br><span class="line">            example.runAsyncRequest(url);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在使用OkHttp发起一次请求时，对于使用者最少存在OkHttpClient 和 Request 的创建可以使用它为我们提供的 Builde给OkHttpClient之后返回的一个已准备好执行的请求。</p>
<p>建造者模式：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。实例化</p>
<p>OKHttpClient和Request的时候，因为有太多的属性需要设置，而且开发者的需求组合千变万化，使用建造 者模式可以让用户不需要关心这个类的内部细节，配置好后，建造者会帮助我们按部就班的初始化表示对象</p>
<p> 同时OkHttp在设计时采用的门面模式，将整个系统的复杂性给隐藏起来，将子系统接口通过一个客户端 OkHttpClient统一暴露出来。OkHttpClient中全是一些配置，比如代理、ssl证书的配置，而call本身是一个接口，我们获得的实际上是一个ReallCall</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; </span><br><span class="line">// Safely publish the Call instance to the EventListener.</span><br><span class="line">RealCall call = new RealCall(client, originalRequest, forWebSocket); </span><br><span class="line">call.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">return call; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Call 的 execute 代表了同步请求，而 enqueue 则代表异步请求。两者唯一区别在于一个会直接发起网络请求，而另一个会使用OkHttp内置的线程池来进行。这就涉及到OkHttp的任务分发器。</p>
<h3 id="分发器"><a href="#分发器" class="headerlink" title="分发器"></a>分发器</h3><p>Dispatcher ，分发器就是来调配请求任务的，内部会包含一个线程池。可以在创建 OkHttpClient 时，传递我们自己定义的线程池来创建分发器。</p>
<p>这个Dispatcher中的成员有:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//异步请求同时存在的最大请求</span><br><span class="line">private int maxRequests = 64;</span><br><span class="line">//异步请求同一域名同时存在的最大请求</span><br><span class="line">private int maxRequestsPerHost = 5;</span><br><span class="line">//闲置任务(没有请求时可执行一些任务，由使用者设置) private @Nullable Runnable idleCallback;</span><br><span class="line">//异步请求使用的线程池</span><br><span class="line">private @Nullable ExecutorService executorService;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">   * Ready async calls in the order they&#x27;ll be run.</span><br><span class="line">   */</span><br><span class="line">  private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line">  /**</span><br><span class="line">   * Running asynchronous calls. Includes canceled calls that haven&#x27;t finished yet.</span><br><span class="line">   */</span><br><span class="line">  private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line">  /**</span><br><span class="line">   * Running synchronous calls. Includes canceled calls that haven&#x27;t finished yet.</span><br><span class="line">   */</span><br><span class="line">  private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h4 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized void executed(RealCall call) &#123;</span><br><span class="line">    runningSyncCalls.add(call);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>因为同步请求不需要线程池，也不存在任何限制。所以分发器仅做一下记录。</p>
<h4 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">synchronized void enqueue(AsyncCall call) &#123;</span><br><span class="line">    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt;</span><br><span class="line">maxRequestsPerHost)     &#123;</span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        executorService().execute(call);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>当正在执行的任务未超过最大限制64，同时 runningCallsForHost(call) &lt; maxRequestsPerHost 同一Host的请求 不超过5个，则会添加到正在执行队列，同时提交给线程池。否则先加入等待队列。</p>
<p>加入线程池直接执行没啥好说的，但是如果加入等待队列后，就需要等待有空闲名额才开始执行。因此每次执行完 一个请求后，都会调用分发器的 finished 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//异步请求调用</span><br><span class="line">void finished(AsyncCall call) &#123;</span><br><span class="line"></span><br><span class="line">		finished(runningAsyncCalls, call, true);</span><br><span class="line">&#125;</span><br><span class="line">//同步请求调用</span><br><span class="line">void finished(RealCall call) &#123;</span><br><span class="line"></span><br><span class="line">      finished(runningSyncCalls, call, false); &#125;</span><br><span class="line"></span><br><span class="line">      private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123;</span><br><span class="line"></span><br><span class="line">      int runningCallsCount;</span><br><span class="line">      Runnable idleCallback;</span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">      //不管异步还是同步， 执行完后都要从队列移除(runningSyncCalls/runningAsyncCalls)</span><br><span class="line">      if (!calls.remove(call)) throw new AssertionError(&quot; Call wasn&#x27;t in-flight!&quot; );</span><br><span class="line">      if (promoteCalls) promoteCalls();</span><br><span class="line">      //异步任务和同步任务正在执行的和</span><br><span class="line">      runningCallsCount = runningCallsCount();</span><br><span class="line">      idleCallback = this.idleCallback;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">      // 没有任务执行执行闲置任务</span><br><span class="line">      if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123;</span><br><span class="line">            idleCallback.run();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是 只有异步任务才会存在限制与等待，所以在执行完了移除正在执行队列中的元素后，异步任务结束会 执行 promoteCalls() 。很显然这个方法肯定会重新调配请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void promoteCalls() &#123;</span><br><span class="line">//如果任务满了直接返回</span><br><span class="line">if (runningAsyncCalls.size() &gt;= maxRequests) return; //没有等待执行的任务，返回</span><br><span class="line">if (readyAsyncCalls.isEmpty()) return;</span><br><span class="line">  //遍历等待执行队列</span><br><span class="line">for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">AsyncCall call = i.next(); //等待任务想要执行，还需要满足:这个等待任务请求的Host不能已经存在5个了 if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">            i.remove();</span><br><span class="line">            runningAsyncCalls.add(call);</span><br><span class="line">            executorService().execute(call);</span><br><span class="line">&#125;</span><br><span class="line">        if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>在满足条件下，会把等待队列中的任务移动到 runningAsyncCalls 并交给线程池执行。所以分发器到这里就完了。</p>
<p>逻辑上还是非常简单的。</p>
<p> 用户是不需要直接操作任务分发器的，获得的 RealCall 中就分别提供了 execute 与 enqueue 来开始同步请求或异</p>
<p>步请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response execute() throws IOException &#123;</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">    executed = true;</span><br><span class="line">  &#125;</span><br><span class="line">  captureCallStackTrace();</span><br><span class="line">  timeout.enter();</span><br><span class="line">  eventListener.callStart(this);</span><br><span class="line">  try &#123;</span><br><span class="line">    client.dispatcher().executed(this);</span><br><span class="line">    Response result = getResponseWithInterceptorChain();</span><br><span class="line">    if (result == null) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">    return result;</span><br><span class="line">  &#125; catch (IOException e) &#123;</span><br><span class="line">    e = timeoutExit(e);</span><br><span class="line">    eventListener.callFailed(this, e);</span><br><span class="line">    throw e;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    client.dispatcher().finished(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步请求的后续同时是调用 getResponseWithInterceptorChain() 来执行请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public void enqueue(Callback responseCallback) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">        executed = true;</span><br><span class="line">    &#125;</span><br><span class="line">captureCallStackTrace();</span><br><span class="line">eventListener.callStart(this);</span><br><span class="line">//调用分发器</span><br><span class="line">client.dispatcher().enqueue(new AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果该 RealCall 已经执行过了，再次执行是不允许的。异步请求会把一个 AsyncCall 提交给分发器。</p>
<p>AsyncCall 实际上是一个 Runnable 的子类,使用线程启动一个 Runnable 时会执行 run 方法，在 AsyncCall 中被 重定向到 execute 方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">final class AsyncCall extends NamedRunnable &#123;</span><br><span class="line">  private final Callback responseCallback;</span><br><span class="line"></span><br><span class="line">  AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">    super(&quot;OkHttp %s&quot;, redactedUrl());</span><br><span class="line">    this.responseCallback = responseCallback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String host() &#123;</span><br><span class="line">    return originalRequest.url().host();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Request request() &#123;</span><br><span class="line">    return originalRequest;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RealCall get() &#123;</span><br><span class="line">    return RealCall.this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Attempt to enqueue this async call on &#123;@code executorService&#125;. This will attempt to clean up</span><br><span class="line">   * if the executor has been shut down by reporting the call as failed.</span><br><span class="line">   */</span><br><span class="line">  void executeOn(ExecutorService executorService) &#123;</span><br><span class="line">    assert (!Thread.holdsLock(client.dispatcher()));</span><br><span class="line">    boolean success = false;</span><br><span class="line">    try &#123;</span><br><span class="line">      executorService.execute(this);</span><br><span class="line">      success = true;</span><br><span class="line">    &#125; catch (RejectedExecutionException e) &#123;</span><br><span class="line">      InterruptedIOException ioException = new InterruptedIOException(&quot;executor rejected&quot;);</span><br><span class="line">      ioException.initCause(e);</span><br><span class="line">      eventListener.callFailed(RealCall.this, ioException);</span><br><span class="line">      responseCallback.onFailure(RealCall.this, ioException);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (!success) &#123;</span><br><span class="line">        client.dispatcher().finished(this); // This call is no longer running!</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override protected void execute() &#123;</span><br><span class="line">    boolean signalledCallback = false;</span><br><span class="line">    timeout.enter();</span><br><span class="line">    try &#123;</span><br><span class="line">      Response response = getResponseWithInterceptorChain();</span><br><span class="line">      if (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">        signalledCallback = true;</span><br><span class="line">        responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        signalledCallback = true;</span><br><span class="line">        responseCallback.onResponse(RealCall.this, response);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      e = timeoutExit(e);</span><br><span class="line">      if (signalledCallback) &#123;</span><br><span class="line">        // Do not signal the callback twice!</span><br><span class="line">        Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        eventListener.callFailed(RealCall.this, e);</span><br><span class="line">        responseCallback.onFailure(RealCall.this, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      client.dispatcher().finished(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>同时 AsyncCall 也是 RealCall 的普通内部类，这意味着它是持有外部类 RealCall 的引用，可以获得直接调用外</p>
<p>部类的方法。</p>
<p>可以看到无论是同步还是异步请求实际上真正执行请求的工作都在 getResponseWithInterceptorChain() 中。这个</p>
<p>方法就是整个OkHttp的核心:拦截器责任链。但是在介绍责任链之前，我们再来回顾一下线程池的基础知识。</p>
<h4 id="分发器线程池"><a href="#分发器线程池" class="headerlink" title="分发器线程池"></a>分发器线程池</h4><p>前面我们提过，分发器就是来调配请求任务的，内部会包含一个线程池。当异步请求时，会将请求任务交给线程池 来执行。那分发器中默认的线程池是如何定义的呢?为什么要这么定义?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public synchronized ExecutorService executorService() &#123;</span><br><span class="line">  if (executorService == null) &#123;</span><br><span class="line">    executorService = new ThreadPoolExecutor(0,//核心线程数</span><br><span class="line">    Integer.MAX_VALUE,//最大线程数 </span><br><span class="line">    60,//最大线程数的保活时间</span><br><span class="line">    TimeUnit.SECONDS,//最大线程数的保活时间单位</span><br><span class="line">        new SynchronousQueue&lt;Runnable&gt;(),请求队列</span><br><span class="line">        Util.threadFactory(&quot;OkHttp Dispatcher&quot;, </span><br><span class="line">        false));</span><br><span class="line">  &#125;</span><br><span class="line">  return executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在OkHttp的分发器中的线程池定义如上，其实就和 Executors.newCachedThreadPool() 创建的线程一样。首先核</p>
<p>心线程为0，表示线程池不会一直为我们缓存线程，线程池中所有线程都是在60s内没有工作就会被回收。而最大线</p>
<p>程 Integer.MAX_VALUE 与等待队列 SynchronousQueue 的组合能够得到最大的吞吐量。即当需要线程池执行任务</p>
<p>时，如果不存在空闲线程不需要等待，马上新建线程执行任务!等待队列的不同指定了线程池的不同排队机制。一</p>
<p>般来说，等待队列 BlockingQueue 有: ArrayBlockingQueue 、 LinkedBlockingQueue 与 SynchronousQueue 。</p>
<p>假设向线程池提交任务时，核心线程都被占用的情况下:</p>
<p>ArrayBlockingQueue :基于数组的阻塞队列，初始化需要指定固定大小。</p>
<p>当使用此队列时，向线程池提交任务，会首先加入到等待队列中，当等待队列满了之后，再次提交任务，尝试加入<br>队列就会失败，这时就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任务。所以<br>最终可能出现后提交的任务先执行，而先提交的任务一直在等待。</p>
<p>LinkedBlockingQueue :基于链表实现的阻塞队列，初始化可以指定大小，也可以不指定。</p>
<p>当指定大小后，行为就和 ArrayBlockingQueu 一致。而如果未指定大小，则会使用默认的 Integer.MAX_VALUE 作</p>
<p>为队列大小。这时候就会出现线程池的最大线程数参数无用，因为无论如何，向线程池提交任务加入等待队列都会<br>成功。最终意味着所有任务都是在核心线程执行。如果核心线程一直被占，那就一直等待。</p>
<p>SynchronousQueue : 无容量的队列。</p>
<p>使用此队列意味着希望获得最大并发量。因为无论如何，向线程池提交任务，往队列提交任务都会失败。而失败后<br>如果没有空闲的非核心线程，就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任</p>
<p>务。完全没有任何等待，唯一制约它的就是最大线程数的个数。因此一般配合 Integer.MAX_VALUE 就实现了真正的</p>
<p>无等待。</p>
<p>但是需要注意的时，我们都知道，进程的内存是存在限制的，而每一个线程都需要分配一定的内存。所以线程并不</p>
<p>能无限个数。那么当设置最大线程数为 Integer.MAX_VALUE 时，OkHttp同时还有最大请求任务执行个数: 64的限</p>
<p>制。这样即解决了这个问题同时也能获得最大吞吐。</p>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>OkHttp最核心的工作是在 getResponseWithInterceptorChain() 中进行，在进入这个方法分析之前，我们先来了解什么是责任链模式，<br>因为此方法就是利用的责任链模式完成一步步的请求 一个接收者。</p>
<p>责任链顾名思义就是由一系列的负责者构成的一个链条，类似于工厂流水线。</p>
<h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p> 为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">     ┌─────────┐</span><br><span class="line">     │ Request │</span><br><span class="line">     └─────────┘</span><br><span class="line">┌ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┐</span><br><span class="line">          ▼</span><br><span class="line">│  ┌─────────────┐  │</span><br><span class="line">   │ ProcessorA  │</span><br><span class="line">│  └─────────────┘  │</span><br><span class="line">│         ▼         │</span><br><span class="line">   ┌─────────────┐</span><br><span class="line">│  │ ProcessorB  │  │</span><br><span class="line">   └─────────────┘</span><br><span class="line">          ▼</span><br><span class="line">│  ┌─────────────┐  │</span><br><span class="line">   │ ProcessorC  │</span><br><span class="line">│  └─────────────┘  │</span><br><span class="line">└ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┘</span><br><span class="line">          ▼</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//传递者</span><br><span class="line">abstract class Handler&#123;</span><br><span class="line">//责任链中下一个传递者</span><br><span class="line">protected Handler nextHandler;</span><br><span class="line">    boolean request(String msg);</span><br><span class="line">    public void setNextHandler(Handler handler)&#123;</span><br><span class="line">		nextHandler = handler;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class AHandler extends Handler&#123;</span><br><span class="line">    public boolean request(String msg)&#123;</span><br><span class="line">     System.out.println(&quot;A&quot;+msg);</span><br><span class="line">        boolean resp = nextHandler.request(msg);</span><br><span class="line">				return resp;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class BHandler extends Handler&#123;</span><br><span class="line">    public boolean request(String msg)&#123;</span><br><span class="line">         System.out.println(&quot;B&quot;+msg);</span><br><span class="line">        boolean resp = nextHandler.request();</span><br><span class="line">				return resp;</span><br><span class="line">&#125;</span><br><span class="line">public class CHandler extends Handler&#123;</span><br><span class="line">    public boolean request(String msg)&#123;</span><br><span class="line">         System.out.println(&quot;C&quot;+msg);</span><br><span class="line">        boolean resp = nextHandler.request();</span><br><span class="line">				return resp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AHandler ahandler = new AHandler();</span><br><span class="line">BHandler bhandler = new BHandler();</span><br><span class="line">CHandler chandler = new CHandler();</span><br><span class="line">ahandler.setNextHandler(bhandler);</span><br><span class="line">bhandler.setNextHandler(chandler);</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   ahandler.request(&quot;处理消息&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在责任链模式中，每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象 决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的 情况下动态的重 新组织链和分配责任。处理者有两个选择:承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象 所接受。</p>
<h4 id="拦截器流程"><a href="#拦截器流程" class="headerlink" title="拦截器流程"></a>拦截器流程</h4><img src="/2021/02/01/OKhttp/%E6%8B%A6%E6%88%AA%E5%99%A8%E6%B5%81%E7%A8%8B.png" class="">

<p>请求会被交给责任链中的一个个拦截器。默认情况下有五大拦截器：</p>
<ol>
<li><p>RetryAndFollowUpInterceptor</p>
<p>第一个接触到请求，最后接触到响应；负责判断是否需要重新发起整个请求</p>
</li>
<li><p>BridgeInterceptor</p>
<p>补全请求，并对响应进行额外处理</p>
</li>
<li><p>CacheInterceptor</p>
<p>请求前查询缓存，获得响应并判断是否需要缓存</p>
</li>
<li><p>ConnectInterceptor</p>
<p>与服务器完成TCP连接</p>
</li>
<li><p>CallServerInterceptor</p>
<p>与服务器通信；封装请求数据与解析响应数据(如：HTTP报文)</p>
</li>
</ol>
<h4 id="拦截器详情"><a href="#拦截器详情" class="headerlink" title="拦截器详情"></a>拦截器详情</h4><h5 id="一、重试及重定向拦截器"><a href="#一、重试及重定向拦截器" class="headerlink" title="一、重试及重定向拦截器"></a>一、重试及重定向拦截器</h5><p>第一个拦截器:RetryAndFollowUpInterceptor ，主要就是完成两件事情：重试与重定向。</p>
<h6 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h6><h6 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h6><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><h5 id="二、桥接拦截器"><a href="#二、桥接拦截器" class="headerlink" title="二、桥接拦截器"></a>二、桥接拦截器</h5><h6 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h6><h5 id="三、缓存拦截器"><a href="#三、缓存拦截器" class="headerlink" title="三、缓存拦截器"></a>三、缓存拦截器</h5><h6 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h6><h6 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h6><h6 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h6><h6 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h6><h5 id="四、连接拦截器"><a href="#四、连接拦截器" class="headerlink" title="四、连接拦截器"></a>四、连接拦截器</h5><h5 id="五、请求服务器拦截器"><a href="#五、请求服务器拦截器" class="headerlink" title="五、请求服务器拦截器"></a>五、请求服务器拦截器</h5><h3 id="OkHttp总结"><a href="#OkHttp总结" class="headerlink" title="OkHttp总结"></a>OkHttp总结</h3><p>整个OkHttp功能的实现就在这五个默认的拦截器中，所以先理解拦截器模式的工作机制是先决条件。这五个拦截 器分别为: 重试拦截器、桥接拦截器、缓存拦截器、连接拦截器、请求服务拦截器。每一个拦截器负责的工作不一 样，就好像工厂流水线，最终经过这五道工序，就完成了最终的产品。</p>
<p>但是与流水线不同的是，OkHttp中的拦截器每次发起请求都会在交给下一个拦截器之前干一些事情，在获得了结 果之后又干一些事情。整个过程在请求向是顺序的，而响应向则是逆序。</p>
<p>当用户发起一个请求后，会由任务分发起Dispatcher将请求包装并交给重试拦截器处理。</p>
<p>1、重试拦截器在交出(交给下一个拦截器)之前，负责判断用户是否取消了请求；在获得了结果之后，会根据响应码 判断是否需要重定向，如果满足条件那么就会重启执行所有拦截器。</p>
<p>2、桥接拦截器在交出之前，负责将HTTP协议必备的请求头加入其中(如：Host)并添加一些默认的行为(如：GZIP 压缩)；在获得了结果后，调用保存cookie接口并解析GZIP数据。</p>
<p>3、缓存拦截器顾名思义，交出之前读取并判断是否使用缓存；获得结果后判断是否缓存。</p>
<p>4、连接拦截器在交出之前，负责找到或者新建一个连接，并获得对应的socket流；在获得结果后不进行额外的处 理。</p>
<p>5、请求服务器拦截器进行真正的与服务器的通信，向服务器发送数据，解析读取的响应数据。</p>
<p>在经过了这一系列的流程后，就完成了一次HTTP请求！</p>
<h2 id="补充-代理"><a href="#补充-代理" class="headerlink" title="补充: 代理"></a>补充: 代理</h2>
      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2020/05/01/hello-world/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2023-05-06 08:05:30
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/android/" title="android">
                        #android
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/okhttp/" title="okhttp">
                        #okhttp
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2023/03/07/RelaxWebView/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#OkHttp%E4%BB%8B%E7%BB%8D"><span class="toc-text">OkHttp介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">使用流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E5%99%A8"><span class="toc-text">分发器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-text">同步请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-text">异步请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E5%99%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">分发器线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-text">责任链模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">拦截器流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E8%AF%A6%E6%83%85"><span class="toc-text">拦截器详情</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%87%8D%E8%AF%95%E5%8F%8A%E9%87%8D%E5%AE%9A%E5%90%91%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">一、重试及重定向拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%87%8D%E8%AF%95"><span class="toc-text">重试</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">重定向</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A1%A5%E6%8E%A5%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">二、桥接拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BC%93%E5%AD%98%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">三、缓存拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="toc-text">缓存策略</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B"><span class="toc-text">详细流程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%BF%9E%E6%8E%A5%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">四、连接拦截器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">五、请求服务器拦截器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OkHttp%E6%80%BB%E7%BB%93"><span class="toc-text">OkHttp总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-%E4%BB%A3%E7%90%86"><span class="toc-text">补充: 代理</span></a>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/relaxgao-lab/RelaxWebView">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a href="/about/">Copyright © 2023 relax</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + Okhttp%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90 + '&url=' + http%3A%2F%2Fexample.com%2F2021%2F02%2F01%2FOKhttp%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://example.com/2021/02/01/OKhttp/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
